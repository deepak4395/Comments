import fetch from 'cross-fetch';\n\nexport type HFLabel = { label: string; score: number };\nexport type ModerationResult = {\n  safe: boolean | null;\n  categories: Record<string, number>;\n  scores: HFLabel[];\n  raw: any;\n};\n\nexport type GenerationResult = {\n  text: string;\n  raw: any;\n};\n\nconst HF_API_URL = 'https://api-inference.huggingface.co/models';\nconst DEFAULT_MODERATION_MODEL = 'unitary/toxic-bert';\nconst DEFAULT_GENERATION_MODEL = 'gpt2';\nconst DEFAULT_TIMEOUT_MS = 8000;\nconst DEFAULT_UNSAFE_THRESHOLD = 0.75;\n\nfunction getToken(): string {\n  const t = process.env.HF_API_TOKEN;\n  if (!t) throw new Error('Missing HF_API_TOKEN environment variable. Add it to your environment or repo secrets.');\n  return t;\n}\n\nasync function postWithTimeout(url: string, body: any, timeoutMs = DEFAULT_TIMEOUT_MS) {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeoutMs);\n  try {\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${getToken()}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n      signal: controller.signal,\n    });\n    const raw = await res.json().catch(() => null);\n    return { ok: res.ok, status: res.status, raw };\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nexport async function moderateText(text: string, modelName = DEFAULT_MODERATION_MODEL): Promise<ModerationResult> {\n  try {\n    const url = `${HF_API_URL}/${encodeURIComponent(modelName)}`;\n    const { ok, status, raw } = await postWithTimeout(url, { inputs: text });\n\n    let scores: HFLabel[] = [];\n    if (Array.isArray(raw) && raw.length > 0 && raw[0].label && typeof raw[0].score === 'number') {\n      scores = raw as HFLabel[];\n    } else if (Array.isArray(raw) && raw.every((r: any) => typeof r === 'object' && 'label' in r)) {\n      scores = raw as HFLabel[];\n    } else if (raw && Array.isArray(raw.labels)) {\n      const labels = raw.labels || [];\n      const sc = raw.scores || [];\n      scores = labels.map((l: string, i: number) => ({ label: l, score: sc[i] ?? 0 }));\n    } else if (raw && raw.error) {\n      return { safe: null, categories: {}, scores: [], raw };\n    } else {\n      return { safe: null, categories: {}, scores: [], raw };\n    }\n\n    const categories: Record<string, number> = {};\n    for (const s of scores) categories[s.label] = s.score;\n\n    const unsafe = scores.some((s) => s.score >= DEFAULT_UNSAFE_THRESHOLD && /toxic|abuse|hate|sexual|sex|threat|insult/i.test(s.label));\n\n    return { safe: !unsafe, categories, scores, raw };\n  } catch (err: any) {\n    return { safe: null, categories: {}, scores: [], raw: { error: String(err) } };\n  }\n}\n\nexport async function generateAnswer(prompt: string, modelName = DEFAULT_GENERATION_MODEL, max_new_tokens = 200): Promise<GenerationResult> {\n  try {\n    const url = `${HF_API_URL}/${encodeURIComponent(modelName)}`;\n    const body = { inputs: prompt, parameters: { max_new_tokens } };\n    const { ok, status, raw } = await postWithTimeout(url, body, 20000);\n\n    let text = '';\n    if (Array.isArray(raw) && raw[0] && typeof raw[0].generated_text === 'string') {\n      text = raw[0].generated_text as string;\n    } else if (raw && typeof raw.generated_text === 'string') {\n      text = raw.generated_text;\n    } else {\n      text = JSON.stringify(raw);\n    }\n    return { text, raw };\n  } catch (err: any) {\n    return { text: '', raw: { error: String(err) } };\n  }\n}\n\nexport default { moderateText, generateAnswer };